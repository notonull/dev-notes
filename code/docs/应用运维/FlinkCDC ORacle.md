## 1️⃣ `scan.incremental.snapshot.enabled = false`

### 执行方案

- **全量**：单线程 SQL 查询全表数据（snapshot）。
- **增量**：全量完成后，通过 **LogMiner** 捕获 redo log 里的 INSERT/UPDATE/DELETE。

### 备选方案

- 可使用 **XStream** 替代 LogMiner 捕获增量。

### 优缺点

| 优点                                     | 缺点                                 |
| ---------------------------------------- | ------------------------------------ |
| 实现简单，配置容易                       | 全量阶段耗时长，不并行，源端压力集中 |
| 对源端性能影响可控（全量期间增量未开启） | 全量完成前增量有窗口，可能丢失数据   |

### 推荐场景

- 表数据量小 (<100万行)
- 源端性能敏感
- 对实时性要求不高

------

## 2️⃣ `scan.incremental.snapshot.enabled = true`

### 执行方案

- **全量**：按主键/分页拆分，全量并行读取。
- **增量**：全量读取期间即可通过 redo log 捕获增量变化（LogMiner 或 XStream）。
- **全量+增量并行**：实现无丢失窗口。

### 备选方案

- **XStream** 代替 LogMiner 捕获增量，可并行，提高性能，减轻源端压力。

### 优缺点

| 优点                             | 缺点                                      |
| -------------------------------- | ----------------------------------------- |
| 支持大表并行全量                 | 配置复杂，对 redo log 查询压力大          |
| 全量期间即可捕获增量，无丢失窗口 | 每个 task 都会访问 redo log，总体压力增加 |
| 实时性高                         | 对源端要求高，需评估性能                  |

### 推荐场景

- 大表 (百万~千万级)
- 高实时性场景
- 可接受源端一定压力
- 想减少全量和增量之间的数据丢失

------

### 🔹 总结建议

| 参数  | 推荐执行方案               | 备选方案 | 适用场景                       |
| ----- | -------------------------- | -------- | ------------------------------ |
| false | 全量单线程 → 增量 LogMiner | XStream  | 小表、低实时性、源端敏感       |
| true  | 并行全量 + 增量 LogMiner   | XStream  | 大表、高实时性、可接受源端压力 |